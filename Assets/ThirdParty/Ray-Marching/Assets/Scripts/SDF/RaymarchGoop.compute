#include "UnityCG.cginc"
#pragma kernel CSMain

Texture2D<float4> Source;
Texture2D<float4> Depth;
RWTexture2D<float4> Destination;

float4x4 _CameraToWorld;
float4x4 _WorldToCamera;
float4x4 _CameraInverseProjection;

float3 _Light;
int _PositionLight;
float _SceneBlend;
static const float maxDst = 50;
static const float epsilon = 0.01f;
int _NumShapes;

struct Shape {
    float3 position;
    float3 size;
    float3 colour;
    float radius;
    int shapeType;
    int operation;
    float blendStrength;
    int numChildren;
};
StructuredBuffer<Shape> _Shapes;

struct Ray {
    float3 origin;
    float3 direction;
};

float SphereDistance(float3 eye, float3 centre, float radius) {
    return distance(eye, centre) - radius;
}

float CubeDistance(float3 eye, float3 centre, float3 size) {
    float3 o = abs(eye-centre) -size;
    float ud = length(max(o,0));
    float n = max(max(min(o.x,0),min(o.y,0)), min(o.z,0));
    return ud+n;
}

// Following distance functions from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm
float TorusDistance(float3 eye, float3 centre, float r1, float r2)
{   
    float2 q = float2(length((eye-centre).xz)-r1,eye.y-centre.y);
    return length(q)-r2;
}

float PrismDistance(float3 eye, float3 centre, float2 h) {
    float3 q = abs(eye-centre);
    return max(q.z-h.y,max(q.x*0.866025+eye.y*0.5,-eye.y)-h.x*0.5);
}

float CapsuleDistance(float3 eye, float3 a, float3 b, float r) {
    float3 pa = eye - a;
    float3 ba = b - a;
    float h = clamp(dot(pa,ba)/dot(ba,ba),0,1);
    return length(pa - ba*h) - r;
}

float CylinderDistance(float3 eye, float3 centre, float2 h) {
    float3 eyeCentre = eye-centre;
    float2 d = abs(float2(length((eyeCentre).xz), eyeCentre.y)) - h;
    return length(max(d,0.0)) + max(min(d.x,0),min(d.y,0));
}

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv) {
    float3 origin = mul(unity_CameraToWorld, float4(0,0,0,1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv,0,1)).xyz;
    direction = mul(unity_CameraToWorld, float4(direction,0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin,direction);
}

// polynomial smooth min (k = 0.1);
// from https://www.iquilezles.org/www/articles/smin/smin.htm
float4 Blend( float a, float b, float3 colA, float3 colB, float k ) {
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
    float blendDst = lerp( b, a, h ) - k*h*(1.0-h);
    float3 blendCol = lerp(colB,colA,h);
    return float4(blendCol, blendDst);
}

float BlendDistance( float a, float b, float k ) {
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
    float blendDst = lerp( b, a, h ) - k*h*(1.0-h);
    return blendDst;
}

float CombineDistance(float dstA, float dstB, int operation, float blendStrength) {
    float dst = dstA;
    dst = BlendDistance(dstA,dstB,blendStrength);
    return dst;
}

float4 Combine(float dstA, float dstB, float3 colourA, float3 colourB, int operation, float blendStrength) {
    float dst = dstA;
    float3 colour = colourA;
    float4 blend = Blend(dstA,dstB,colourA,colourB, blendStrength);
    dst = blend.w;
    colour = blend.xyz;
    return float4(colour,dst);
}

float GetShapeDistance(Shape shape, float3 eye) {
    switch(shape.shapeType) {
        case 0: return SphereDistance(eye, shape.position, shape.size.x*shape.radius);
        case 1: return CubeDistance(eye, shape.position, shape.size);
        case 2: return TorusDistance(eye, shape.position, shape.size.x, shape.radius);
        case 3: return CylinderDistance(eye, shape.position, shape.size.x*shape.radius);
        case 4: return CapsuleDistance(eye, shape.position, shape.size, shape.radius);
    }

    return maxDst;
}

float SceneDistance(float3 eye, float sceneDist) {
    float globalDst = maxDst;
    for (int i = 0; i < _NumShapes; ++i) {
        Shape shape = _Shapes[i];
        int numChildren = shape.numChildren;
        float localDst = GetShapeDistance(shape,eye);
        for (int j = 0; j < numChildren; ++j) {
            Shape childShape = _Shapes[i+j+1];
            float childDst = GetShapeDistance(childShape,eye);
            localDst = CombineDistance(localDst, childDst, childShape.operation, childShape.blendStrength);
        }
        i+=numChildren; // skip over children in outer loop
        globalDst = CombineDistance(globalDst, localDst, shape.operation, shape.blendStrength);
    }
    // Now smooth with the scene
    globalDst = CombineDistance(globalDst, sceneDist, 1, _SceneBlend);
    return globalDst;
}

float4 SceneInfo(float3 eye, float sceneDist, float3 sceneColor) {
    float globalDst = maxDst;
    float3 globalColour = 1;
    
    for (int i = 0; i < _NumShapes; ++i) {
        Shape shape = _Shapes[i];
        int numChildren = shape.numChildren;

        float localDst = GetShapeDistance(shape,eye);
        float3 localColour = shape.colour;

        for (int j = 0; j < numChildren; ++j) {
            Shape childShape = _Shapes[i+j+1];
            float childDst = GetShapeDistance(childShape,eye);

            float4 combined = Combine(localDst, childDst, localColour, childShape.colour, childShape.operation, childShape.blendStrength);
            localColour = combined.xyz;
            localDst = combined.w;
        }
        i+=numChildren; // skip over children in outer loop
        
        float4 globalCombined = Combine(globalDst, localDst, globalColour, localColour, shape.operation, shape.blendStrength);
        globalColour = globalCombined.xyz;
        globalDst = globalCombined.w;        
    }

    // Now smooth with the scene
    float4 sceneCombined = Combine(globalDst, sceneDist, globalColour, sceneColor, 1, _SceneBlend);
    globalColour = sceneCombined.xyz;
    globalDst = sceneCombined.w; 

    return float4(globalColour, globalDst);
}

float3 EstimateNormal(float3 p, float sceneDist) {
    float x = SceneDistance(float3(p.x+epsilon,p.y,p.z), sceneDist) - SceneDistance(float3(p.x-epsilon,p.y,p.z), sceneDist);
    float y = SceneDistance(float3(p.x,p.y+epsilon,p.z), sceneDist) - SceneDistance(float3(p.x,p.y-epsilon,p.z), sceneDist);
    float z = SceneDistance(float3(p.x,p.y,p.z+epsilon), sceneDist) - SceneDistance(float3(p.x,p.y,p.z-epsilon), sceneDist);
    return normalize(float3(x,y,z));
}

float CalculateShadow(Ray ray, float dstToShadePoint, float sceneDist) {
    float rayDst = 0;
    int marchSteps = 0;
    float shadowIntensity = .2;
    float brightness = 1;

    while (rayDst < dstToShadePoint) {
        marchSteps ++;
        float dst = SceneDistance(ray.origin, sceneDist);
        if (dst <= epsilon) {
            return shadowIntensity;
        }
        brightness = min(brightness,dst*200);

        ray.origin += ray.direction * dst;
        rayDst += dst;
    }
    return shadowIntensity + (1-shadowIntensity) * brightness;
}

static const float refractPower = 50;
static const float specularPower = 30;
static const float minAlbedo = 0.1;
static const float shadowBias = epsilon * 50;
static const float transmissionAmount = 0.2;
static const float fresnelBias = -0.25;
static const float fresnelScale = 0.4;
static const float fresnelPower = 1.8;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width,height;
    Destination.GetDimensions(width, height);

    uint swidth, sheight;
    Source.GetDimensions(swidth, sheight);
    uint2 sourceid = uint2(((float2(id.xy) / float2(width,height))*float2(swidth,sheight)).xy);

    Destination[id.xy] = float4(1,1,1,0);

    float2 uv = id.xy / float2(width,height) * 2 - 1;
    // I use these two matrix multiplications to correct for distortion at the edges of the screen.
    // I don't really know how they work and there's probably a simpler way to do so.
    float4 viewVector = mul(_CameraInverseProjection, float4(uv, 0, -1));
    float3 rayLength = mul(_CameraToWorld, float4(viewVector.xyz,0)).xyz;
    float nonlin_depth = Depth[sourceid.xy].r;
    float screenDist = LinearEyeDepth(nonlin_depth) * length(rayLength);
    // This is to prevent weirdness when we hit the exact start or end of the clipping planes
    if (nonlin_depth == 1 || nonlin_depth == 0) {
        screenDist = maxDst;
    }
    float sceneDistFromEye = screenDist;

    float rayDst = 0;
    Ray ray = CreateCameraRay(uv);
    int marchSteps = 0;

    while (rayDst < maxDst && rayDst < screenDist)  {
        marchSteps ++;
        float dst = SceneDistance(ray.origin, sceneDistFromEye);
        
        if (dst <= epsilon) {
            // If we hit the scene, just kill the pixel.
            if (sceneDistFromEye <= dst) {
                break;
            }
            float4 sceneInfo = SceneInfo(ray.origin, sceneDistFromEye, float3(1,1,1));
            float3 pointOnSurface = ray.origin + ray.direction * dst;
            float3 normal = EstimateNormal(pointOnSurface - ray.direction * epsilon, sceneDistFromEye);
            float3 lightDir = lerp(-_Light,normalize(_Light-ray.origin),_PositionLight);
            //float lighting = saturate(saturate(dot(normal,lightDir)));
            float3 col = sceneInfo.xyz;
            
            // Shadow
            float3 offsetPos = pointOnSurface + normal * shadowBias;
            float3 dirToLight = lerp(-_Light,normalize(_Light- offsetPos),_PositionLight);

            float3 refract = -mul(_WorldToCamera, float4(normal.xyz,0))*refractPower;
            refract.z = 0;
            float3 reflect = normalize(2 * dot(normal, -lightDir) * normal + lightDir);


            float mainTransmission = max(minAlbedo , -dot(normal, lightDir)) * transmissionAmount;
            float fresnel = 1-saturate( fresnelBias + fresnelScale * pow( abs(1.0 - dot( normal, ray.direction )), fresnelPower ) );

            float lambert = max((dot(lightDir,normal)+1)/2,minAlbedo);
            float specular = pow(abs(saturate(dot(reflect, ray.direction))), specularPower); 

            float dstToLight = lerp(maxDst, distance(offsetPos,_Light), _PositionLight);
            //float shadow = CalculateShadow(ray, dstToLight);

            //Destination[id.xy] = float4(col * lighting * shadow, 1);
            float2 refractUV = float2(clamp(sourceid.x+refract.x, 0, swidth-1), clamp(sourceid.y+refract.y, 0, sheight-1));

            //Destination[id.xy] = Source[refractUV]*float4(col.xyz,1)*lambert+specular+fresnel+float4(col.xyz,1)*mainTransmission;// float4(col * lighting * shadow, 1);
            float sceneTransparency = saturate(sceneDistFromEye/_SceneBlend);

            float4 finalColor = saturate(Source[refractUV]*float4(col.xyz,1)*lambert+(specular+fresnel+float4(col.xyz,1)*mainTransmission)*sceneTransparency);
            finalColor.a = sceneTransparency;
            Destination[id.xy] = finalColor;
            return;
        }
        sceneDistFromEye -= dst;
        ray.origin += ray.direction * dst;
        rayDst += max(dst,epsilon);
    }
    /*fixed4 color = float4(0,0,0,1);
    if (marchSteps < 8) {
        color = float4(0,1,0,1);
    } else if (marchSteps < 16) {
        color = float4(0,0,1,1);
    } else if (marchSteps < 32) {
        color = float4(1,1,0,1);
    } else {
        color = float4(1,0,0,1);
    }
    Destination[id.xy] = color;*/
}
